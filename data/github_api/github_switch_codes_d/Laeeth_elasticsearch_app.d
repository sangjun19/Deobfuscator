// Repository: Laeeth/elasticsearch
// File: source/app.d

module generate_elasticsearch;
import asdf: Asdf;

enum targetFile = "elasticsearch.d";

// autogenerated wrapping fails for various reasons for these
// just blacklist and add manually if needed until we can figure out why

string[] blacklist = [
];

int main(string[] args)
{
	import std.file;
	import std.string : strip;
	import std.algorithm : map, filter, sort, uniq;
	import std.conv : to;
	import asdf : parseJson;
	import std.stdio : stderr,writefln, writeln;
	import std.array : array, join;

	ApiCall[string] apiCalls;
	auto sources = dirEntries("api_json","*.json",SpanMode.depth);
	foreach(source; sources)
	{
		auto jsonText = readText(source.name);
		auto json = parseJson(jsonText);
		apiCalls = apiCalls.merge(parseAPI(json));
	}
	// std.file.write(targetFile,apis.generateAPI);
	foreach(call;apiCalls.keys.sort)
	{
		writeln(apiCalls[call]);
		writeln("");
		foreach(path;apiCalls[call].paths)
			writeln(path.path,"\t",identifiers(path));
		writeln("\n");
	}
	auto types = apiCalls.byKeyValue.map!(kv => kv.value.params.byKeyValue.map!(kv2 => kv2.value.type).array).join.sort.uniq.array;
	writefln("types: %s",types);
	foreach(k;apiCalls.keys.sort)
	{
		auto call = apiCalls[k];
		foreach(path;0 .. call.paths.length)
		{
			foreach(method;0 .. call.paths[path].methods.length)
			{
				writeln(getPrototype(call,path,method));
			}
		}
	}
	stderr.writefln("success");
	return 0;
}

T[string] merge(T)(T[string] lhs, T[string] rhs)
{
	import std.array : byPair;
	foreach(kv;rhs.byPair)
	{
		lhs[kv.key] = kv.value;
	}
	return lhs;
}

ApiCall[string] parseAPI(ref Asdf json)
{
	ApiCall[string] ret;
	foreach(kv;json.byKeyValue)
	{
		auto key = kv.key.idup;
		auto entry = ApiCall(key,kv.value);
		ret[key] = entry;
	}
	return ret;
}

enum Stability
{
	stable,
	beta,
	experimental,
	unknown,
}

T parseEnum(T)(string value)
if (is( T == enum))
{
	import std.traits: EnumMembers;
	import std.conv : to;
	import std.exception;
	import std.string : toLower;

	value = value.toLower();
	static foreach(U;EnumMembers!T)
	{{
		enum enumString = U.to!string.toLower;
		if (enumString == value || enumString == value ~ "_")
			return U;
	}}
	return T.unknown; // throw new Exception("value " ~ value ~ " not in enum " ~ T.stringof);
}

struct UrlPath
{
	string path;
	string[] methods;
	Part[string] parts;

	this(Asdf json)
	{
		this.path = json["path"].get("");
		this.methods = json["methods"].get!(string[])([]);
		foreach(el;json["parts"].byKeyValue)
		{
			auto key = el.key.idup;
			auto part = Part(key, el.value);
			parts[key] = part;
		}
	}
}

struct Part
{
	string name;
	string type;
	string description;

	this(string name, Asdf json)
	{
		this.name = name;
		this.type = json["type"].get("");
		this.description = json["description"].get("");
	}
}

struct Param
{
	string name;
	ElasticType type;
	string description;

	this(string name, Asdf json)
	{
		this.name = name;
		this.type = parseEnum!ElasticType(json["type"].get(""));
		this.description = json["description"].get("");
	}
}

string[] identifiers(UrlPath path)
{
	import std.algorithm : filter, map;
	import std.string : split;
	import std.range : front, back;
	import std.array : array;

	auto parts = path.path
				.split('/')
				.filter!(p => (p.length>2 && p.front == '{' && p.back == '}' ))
				.map!(p => p[1..$-1])
				.array;
	return parts;
}

struct ApiCall
{
	string name;
	string documentationURL;
	string documentationDescription;
	Stability stability;
	UrlPath[] paths;
	Param[string] params;
	string bodyDescription;

	string description()
	{
		import std.string : split, capitalize;
		auto names = name.split(".");
		if (names.length == 2)
			return names[1] ~ names[0].capitalize;
		else
			return name;
	}

	this(string name, Asdf json)
	{
		import std.conv : to;
		this.name = name;
		this.documentationURL = json["documentation"]["url"].get("");
		this.documentationDescription = json["documentation"]["description"].get("");
		this.stability = parseEnum!(Stability)(json["stability"].get(""));
		foreach(el;json["url"]["paths"].byElement)
		{
			paths ~= UrlPath(el);
		}
		foreach(el;json["params"].byKeyValue)
		{
			auto key = el.key.idup;
			params[key] = Param(key,el.value);
		}
		this.bodyDescription = json["body"]["description"].get("");
	}
}


enum ElasticType
{
	boolean,
	enum_,
	list,
	number,
	string_,
	time_,
	unknown,
}

string toD(ElasticType type)
{
	final switch(type) with(ElasticType)
	{
		case boolean:
			return "bool";
		case enum_:
			return "string";
		case list:
			return "Variable[]";
		case number:
			return "double";
		case string_:
			return "string";
		case time_:
			return "DateTime";
		case unknown:
			return "void";
	}
}

string toD(Param param)
{
	return param.type.toD ~ " "  ~ param.name;
}

bool hasReturn(string method)
{
	return method == "GET";
}

string getPrototype(ApiCall call, size_t pathIndex, size_t methodIndex)
{
    import std.array:Appender,array;
    import std.algorithm:filter,map;
    import std.string:join;

    Appender!string ret;

    auto method = call.paths[pathIndex].methods[methodIndex];
    ret.put(method.hasReturn ? "auto " : "void ");
    ret.put(method ~ "_" ~ call.description);
    ret.put("(");
    auto parts = call.paths[pathIndex].parts;
    auto queryParams = call.params;
    auto params = queryParams.byKeyValue.map!(param => param.value.toD).array;
    if(queryParams.length > 0)
        params ~= ["Variable[string] queryParams = (Variable[string]).init"];
    ret.put(params.join(", "));
    ret.put(")");
    return ret.data;
}
 
