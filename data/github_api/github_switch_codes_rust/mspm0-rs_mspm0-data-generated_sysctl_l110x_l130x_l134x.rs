// Repository: mspm0-rs/mspm0-data-generated
// File: mspm0-metapac/src/peripherals/sysctl_l110x_l130x_l134x.rs

// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[doc = "mem_map."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Sysctl {
    ptr: *mut u8,
}
unsafe impl Send for Sysctl {}
unsafe impl Sync for Sysctl {}
impl Sysctl {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "SYSCTL interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1020usize) as _) }
    }
    #[doc = "SYSCTL interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1028usize) as _) }
    }
    #[doc = "SYSCTL raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1030usize) as _) }
    }
    #[doc = "SYSCTL masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1038usize) as _) }
    }
    #[doc = "SYSCTL interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1040usize) as _) }
    }
    #[doc = "SYSCTL interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1048usize) as _) }
    }
    #[doc = "NMI interrupt index."]
    #[inline(always)]
    pub const fn nmiiidx(self) -> crate::common::Reg<regs::Nmiiidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1050usize) as _) }
    }
    #[doc = "NMI raw interrupt status."]
    #[inline(always)]
    pub const fn nmiris(self) -> crate::common::Reg<regs::Nmi, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1060usize) as _) }
    }
    #[doc = "NMI interrupt set."]
    #[inline(always)]
    pub const fn nmiiset(self) -> crate::common::Reg<regs::Nmi, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1070usize) as _) }
    }
    #[doc = "NMI interrupt clear."]
    #[inline(always)]
    pub const fn nmiiclr(self) -> crate::common::Reg<regs::Nmi, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1078usize) as _) }
    }
    #[doc = "SYSOSC configuration."]
    #[inline(always)]
    pub const fn sysosccfg(self) -> crate::common::Reg<regs::Sysosccfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Main clock (MCLK) configuration."]
    #[inline(always)]
    pub const fn mclkcfg(self) -> crate::common::Reg<regs::Mclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "General clock configuration."]
    #[inline(always)]
    pub const fn genclkcfg(self) -> crate::common::Reg<regs::Genclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1138usize) as _) }
    }
    #[doc = "General clock enable control."]
    #[inline(always)]
    pub const fn genclken(self) -> crate::common::Reg<regs::Genclken, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x113cusize) as _) }
    }
    #[doc = "Power mode configuration."]
    #[inline(always)]
    pub const fn pmodecfg(self) -> crate::common::Reg<regs::Pmodecfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1140usize) as _) }
    }
    #[doc = "Frequency clock counter (FCC) count."]
    #[inline(always)]
    pub const fn fcc(self) -> crate::common::Reg<regs::Fcc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1150usize) as _) }
    }
    #[doc = "SYSOSC user-specified trim."]
    #[inline(always)]
    pub const fn sysosctrimuser(
        self,
    ) -> crate::common::Reg<regs::Sysosctrimuser, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1170usize) as _) }
    }
    #[doc = "SRAM Write Boundary."]
    #[inline(always)]
    pub const fn sramboundary(self) -> crate::common::Reg<regs::Sramboundary, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1178usize) as _) }
    }
    #[doc = "System configuration."]
    #[inline(always)]
    pub const fn systemcfg(self) -> crate::common::Reg<regs::Systemcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1180usize) as _) }
    }
    #[doc = "SYSCTL register write lockout."]
    #[inline(always)]
    pub const fn writelock(self) -> crate::common::Reg<regs::Writelock, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1200usize) as _) }
    }
    #[doc = "Clock module (CKM) status."]
    #[inline(always)]
    pub const fn clkstatus(self) -> crate::common::Reg<regs::Clkstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1204usize) as _) }
    }
    #[doc = "System status information."]
    #[inline(always)]
    pub const fn sysstatus(self) -> crate::common::Reg<regs::Sysstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1208usize) as _) }
    }
    #[doc = "Reset cause."]
    #[inline(always)]
    pub const fn rstcause(self) -> crate::common::Reg<regs::Rstcause, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1220usize) as _) }
    }
    #[doc = "Reset level for application-triggered reset command."]
    #[inline(always)]
    pub const fn resetlevel(self) -> crate::common::Reg<regs::Resetlevel, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1300usize) as _) }
    }
    #[doc = "Execute an application-triggered reset command."]
    #[inline(always)]
    pub const fn resetcmd(self) -> crate::common::Reg<regs::Resetcmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1304usize) as _) }
    }
    #[doc = "BOR threshold selection."]
    #[inline(always)]
    pub const fn borthreshold(self) -> crate::common::Reg<regs::Borthreshold, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1308usize) as _) }
    }
    #[doc = "Set the BOR threshold."]
    #[inline(always)]
    pub const fn borclrcmd(self) -> crate::common::Reg<regs::Borclrcmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x130cusize) as _) }
    }
    #[doc = "SYSOSC frequency correction loop (FCL) ROSC enable."]
    #[inline(always)]
    pub const fn sysoscfclctl(self) -> crate::common::Reg<regs::Sysoscfclctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1310usize) as _) }
    }
    #[doc = "SHUTDOWN IO release control."]
    #[inline(always)]
    pub const fn shdniorel(self) -> crate::common::Reg<regs::Shdniorel, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x131cusize) as _) }
    }
    #[doc = "Disable the reset function of the NRST pin."]
    #[inline(always)]
    pub const fn exrstpin(self) -> crate::common::Reg<regs::Exrstpin, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1320usize) as _) }
    }
    #[doc = "Clear sticky bits of SYSSTATUS."]
    #[inline(always)]
    pub const fn sysstatusclr(self) -> crate::common::Reg<regs::Sysstatusclr, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1324usize) as _) }
    }
    #[doc = "Disable the SWD function on the SWD pins."]
    #[inline(always)]
    pub const fn swdcfg(self) -> crate::common::Reg<regs::Swdcfg, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1328usize) as _) }
    }
    #[doc = "Frequency clock counter start capture."]
    #[inline(always)]
    pub const fn fcccmd(self) -> crate::common::Reg<regs::Fcccmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x132cusize) as _) }
    }
    #[doc = "GPAMP control."]
    #[inline(always)]
    pub const fn pmuopamp(self) -> crate::common::Reg<regs::Pmuopamp, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1380usize) as _) }
    }
    #[doc = "Shutdown storage memory (byte 0)."]
    #[inline(always)]
    pub const fn shutdnstore(
        self,
        n: usize,
    ) -> crate::common::Reg<regs::Shutdnstore, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1400usize + n * 4usize) as _) }
    }
}
pub mod regs {
    #[doc = "Set the BOR threshold."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Borclrcmd(pub u32);
    impl Borclrcmd {
        #[doc = "GO clears any prior BOR violation status indications and attempts to change the active BOR mode to that specified in the LEVEL field of the BORTHRESHOLD register."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GO clears any prior BOR violation status indications and attempts to change the active BOR mode to that specified in the LEVEL field of the BORTHRESHOLD register."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::BorclrcmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::BorclrcmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::BorclrcmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Borclrcmd {
        #[inline(always)]
        fn default() -> Borclrcmd {
            Borclrcmd(0)
        }
    }
    #[doc = "BOR threshold selection."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Borthreshold(pub u32);
    impl Borthreshold {
        #[doc = "LEVEL specifies the desired BOR threshold and BOR mode."]
        #[inline(always)]
        pub const fn level(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x03;
            val as u8
        }
        #[doc = "LEVEL specifies the desired BOR threshold and BOR mode."]
        #[inline(always)]
        pub fn set_level(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Borthreshold {
        #[inline(always)]
        fn default() -> Borthreshold {
            Borthreshold(0)
        }
    }
    #[doc = "Clock module (CKM) status."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkstatus(pub u32);
    impl Clkstatus {
        #[doc = "SYSOSCFREQ indicates the current SYSOSC operating frequency."]
        #[inline(always)]
        pub const fn sysoscfreq(&self) -> super::vals::Sysoscfreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Sysoscfreq::from_bits(val as u8)
        }
        #[doc = "SYSOSCFREQ indicates the current SYSOSC operating frequency."]
        #[inline(always)]
        pub fn set_sysoscfreq(&mut self, val: super::vals::Sysoscfreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "LFCLKMUX indicates if LFCLK is sourced from the internal LFOSC, the low frequency crystal (LFXT), or the LFCLK_IN digital clock input."]
        #[inline(always)]
        pub const fn lfclkmux(&self) -> super::vals::Lfclkmux {
            let val = (self.0 >> 6usize) & 0x03;
            super::vals::Lfclkmux::from_bits(val as u8)
        }
        #[doc = "LFCLKMUX indicates if LFCLK is sourced from the internal LFOSC, the low frequency crystal (LFXT), or the LFCLK_IN digital clock input."]
        #[inline(always)]
        pub fn set_lfclkmux(&mut self, val: super::vals::Lfclkmux) {
            self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
        }
        #[doc = "LFOSCGOOD indicates when the LFOSC startup has completed and the LFOSC is ready for use."]
        #[inline(always)]
        pub const fn lfoscgood(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LFOSCGOOD indicates when the LFOSC startup has completed and the LFOSC is ready for use."]
        #[inline(always)]
        pub fn set_lfoscgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "CURMCLKSEL indicates if MCLK is currently sourced from LFCLK."]
        #[inline(always)]
        pub const fn curmclksel(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "CURMCLKSEL indicates if MCLK is currently sourced from LFCLK."]
        #[inline(always)]
        pub fn set_curmclksel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "FCLMODE indicates if the SYSOSC frequency correction loop (FCL) is enabled."]
        #[inline(always)]
        pub const fn fclmode(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "FCLMODE indicates if the SYSOSC frequency correction loop (FCL) is enabled."]
        #[inline(always)]
        pub fn set_fclmode(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "FCCDONE indicates when a frequency clock counter capture is complete."]
        #[inline(always)]
        pub const fn fccdone(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "FCCDONE indicates when a frequency clock counter capture is complete."]
        #[inline(always)]
        pub fn set_fccdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "OPAMPCLKERR is set when the device clock configuration does not support an enabled OPA mode and the OPA may not be functioning as expected."]
        #[inline(always)]
        pub const fn opampclkerr(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "OPAMPCLKERR is set when the device clock configuration does not support an enabled OPA mode and the OPA may not be functioning as expected."]
        #[inline(always)]
        pub fn set_opampclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "ANACLKERR is set when the device clock configuration does not support an enabled analog peripheral mode and the analog peripheral may not be functioning as expected."]
        #[inline(always)]
        pub const fn anaclkerr(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "ANACLKERR is set when the device clock configuration does not support an enabled analog peripheral mode and the analog peripheral may not be functioning as expected."]
        #[inline(always)]
        pub fn set_anaclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Clkstatus {
        #[inline(always)]
        fn default() -> Clkstatus {
            Clkstatus(0)
        }
    }
    #[doc = "Disable the reset function of the NRST pin."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Exrstpin(pub u32);
    impl Exrstpin {
        #[doc = "Set DISABLE to disable the reset function of the NRST pin. Once set, this configuration is locked until the next POR."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set DISABLE to disable the reset function of the NRST pin. Once set, this configuration is locked until the next POR."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ExrstpinKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ExrstpinKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ExrstpinKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Exrstpin {
        #[inline(always)]
        fn default() -> Exrstpin {
            Exrstpin(0)
        }
    }
    #[doc = "Frequency clock counter (FCC) count."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcc(pub u32);
    impl Fcc {
        #[doc = "Frequency clock counter (FCC) count value."]
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0x003f_ffff;
            val as u32
        }
        #[doc = "Frequency clock counter (FCC) count value."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0x003f_ffff << 0usize)) | (((val as u32) & 0x003f_ffff) << 0usize);
        }
    }
    impl Default for Fcc {
        #[inline(always)]
        fn default() -> Fcc {
            Fcc(0)
        }
    }
    #[doc = "Frequency clock counter start capture."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcccmd(pub u32);
    impl Fcccmd {
        #[doc = "Set GO to start a capture with the frequency clock counter (FCC)."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set GO to start a capture with the frequency clock counter (FCC)."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::FcccmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::FcccmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::FcccmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Fcccmd {
        #[inline(always)]
        fn default() -> Fcccmd {
            Fcccmd(0)
        }
    }
    #[doc = "General clock configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Genclkcfg(pub u32);
    impl Genclkcfg {
        #[doc = "EXCLKSRC selects the source for the CLK_OUT external clock output block. ULPCLK and MFPCLK require the CLK_OUT divider (EXCLKDIVEN) to be enabled."]
        #[inline(always)]
        pub const fn exclksrc(&self) -> super::vals::Exclksrc {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Exclksrc::from_bits(val as u8)
        }
        #[doc = "EXCLKSRC selects the source for the CLK_OUT external clock output block. ULPCLK and MFPCLK require the CLK_OUT divider (EXCLKDIVEN) to be enabled."]
        #[inline(always)]
        pub fn set_exclksrc(&mut self, val: super::vals::Exclksrc) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "EXCLKDIVVAL selects the divider value for the divider in the CLK_OUT external clock output block."]
        #[inline(always)]
        pub const fn exclkdivval(&self) -> super::vals::Exclkdivval {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Exclkdivval::from_bits(val as u8)
        }
        #[doc = "EXCLKDIVVAL selects the divider value for the divider in the CLK_OUT external clock output block."]
        #[inline(always)]
        pub fn set_exclkdivval(&mut self, val: super::vals::Exclkdivval) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "EXCLKDIVEN enables or disables the divider function of the CLK_OUT external clock output block."]
        #[inline(always)]
        pub const fn exclkdiven(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "EXCLKDIVEN enables or disables the divider function of the CLK_OUT external clock output block."]
        #[inline(always)]
        pub fn set_exclkdiven(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "FCCSELCLK selectes the frequency clock counter (FCC) clock source."]
        #[inline(always)]
        pub const fn fccselclk(&self) -> super::vals::Fccselclk {
            let val = (self.0 >> 16usize) & 0x0f;
            super::vals::Fccselclk::from_bits(val as u8)
        }
        #[doc = "FCCSELCLK selectes the frequency clock counter (FCC) clock source."]
        #[inline(always)]
        pub fn set_fccselclk(&mut self, val: super::vals::Fccselclk) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
        }
        #[doc = "FCCTRIGSRC selects the frequency clock counter (FCC) trigger source."]
        #[inline(always)]
        pub const fn fcctrigsrc(&self) -> super::vals::Fcctrigsrc {
            let val = (self.0 >> 20usize) & 0x01;
            super::vals::Fcctrigsrc::from_bits(val as u8)
        }
        #[doc = "FCCTRIGSRC selects the frequency clock counter (FCC) trigger source."]
        #[inline(always)]
        pub fn set_fcctrigsrc(&mut self, val: super::vals::Fcctrigsrc) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
        }
        #[doc = "FCCLVLTRIG selects the frequency clock counter (FCC) trigger mode."]
        #[inline(always)]
        pub const fn fcclvltrig(&self) -> super::vals::Fcclvltrig {
            let val = (self.0 >> 21usize) & 0x01;
            super::vals::Fcclvltrig::from_bits(val as u8)
        }
        #[doc = "FCCLVLTRIG selects the frequency clock counter (FCC) trigger mode."]
        #[inline(always)]
        pub fn set_fcclvltrig(&mut self, val: super::vals::Fcclvltrig) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
        }
        #[doc = "ANACPUMPCFG selects the analog mux charge pump (VBOOST) enable method."]
        #[inline(always)]
        pub const fn anacpumpcfg(&self) -> super::vals::Anacpumpcfg {
            let val = (self.0 >> 22usize) & 0x03;
            super::vals::Anacpumpcfg::from_bits(val as u8)
        }
        #[doc = "ANACPUMPCFG selects the analog mux charge pump (VBOOST) enable method."]
        #[inline(always)]
        pub fn set_anacpumpcfg(&mut self, val: super::vals::Anacpumpcfg) {
            self.0 = (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
        }
        #[doc = "FCCTRIGCNT specifies the number of trigger clock periods in the trigger window. FCCTRIGCNT=0h (one trigger clock period) up to 1Fh (32 trigger clock periods) may be specified."]
        #[inline(always)]
        pub const fn fcctrigcnt(&self) -> u8 {
            let val = (self.0 >> 24usize) & 0x1f;
            val as u8
        }
        #[doc = "FCCTRIGCNT specifies the number of trigger clock periods in the trigger window. FCCTRIGCNT=0h (one trigger clock period) up to 1Fh (32 trigger clock periods) may be specified."]
        #[inline(always)]
        pub fn set_fcctrigcnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
        }
    }
    impl Default for Genclkcfg {
        #[inline(always)]
        fn default() -> Genclkcfg {
            Genclkcfg(0)
        }
    }
    #[doc = "General clock enable control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Genclken(pub u32);
    impl Genclken {
        #[doc = "EXCLKEN enables the CLK_OUT external clock output block."]
        #[inline(always)]
        pub const fn exclken(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "EXCLKEN enables the CLK_OUT external clock output block."]
        #[inline(always)]
        pub fn set_exclken(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "MFPCLKEN enables the middle frequency precision clock (MFPCLK)."]
        #[inline(always)]
        pub const fn mfpclken(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "MFPCLKEN enables the middle frequency precision clock (MFPCLK)."]
        #[inline(always)]
        pub fn set_mfpclken(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Genclken {
        #[inline(always)]
        fn default() -> Genclken {
            Genclken(0)
        }
    }
    #[doc = "SYSCTL interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "The SYSCTL interrupt index (IIDX) register generates a value corresponding to the highest priority pending interrupt source. This value may be used as an address offset for fast, deterministic handling in the interrupt service routine. A read of the IIDX register will clear the corresponding interrupt status in the RIS and MIS registers."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::IidxStat {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::IidxStat::from_bits(val as u8)
        }
        #[doc = "The SYSCTL interrupt index (IIDX) register generates a value corresponding to the highest priority pending interrupt source. This value may be used as an address offset for fast, deterministic handling in the interrupt service routine. A read of the IIDX register will clear the corresponding interrupt status in the RIS and MIS registers."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::IidxStat) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "SYSCTL interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Int(pub u32);
    impl Int {
        #[doc = "Clear the LFOSCGOOD interrupt."]
        #[inline(always)]
        pub const fn lfoscgood(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the LFOSCGOOD interrupt."]
        #[inline(always)]
        pub fn set_lfoscgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[inline(always)]
        pub const fn anaclkerr(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_anaclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Int {
        #[inline(always)]
        fn default() -> Int {
            Int(0)
        }
    }
    #[doc = "Main clock (MCLK) configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mclkcfg(pub u32);
    impl Mclkcfg {
        #[doc = "MDIV may be used to divide the MCLK frequency when MCLK is sourced from SYSOSC. MDIV=0h corresponds to /1 (no divider). MDIV=1h corresponds to /2 (divide-by-2). MDIV=Fh corresponds to /16 (divide-by-16). MDIV may be set between /1 and /16 on an integer basis."]
        #[inline(always)]
        pub const fn mdiv(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "MDIV may be used to divide the MCLK frequency when MCLK is sourced from SYSOSC. MDIV=0h corresponds to /1 (no divider). MDIV=1h corresponds to /2 (divide-by-2). MDIV=Fh corresponds to /16 (divide-by-16). MDIV may be set between /1 and /16 on an integer basis."]
        #[inline(always)]
        pub fn set_mdiv(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "FLASHWAIT specifies the number of flash wait states when MCLK is sourced from HSCLK. FLASHWAIT has no effect when MCLK is sourced from SYSOSC or LFCLK."]
        #[inline(always)]
        pub const fn flashwait(&self) -> super::vals::Flashwait {
            let val = (self.0 >> 8usize) & 0x0f;
            super::vals::Flashwait::from_bits(val as u8)
        }
        #[doc = "FLASHWAIT specifies the number of flash wait states when MCLK is sourced from HSCLK. FLASHWAIT has no effect when MCLK is sourced from SYSOSC or LFCLK."]
        #[inline(always)]
        pub fn set_flashwait(&mut self, val: super::vals::Flashwait) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u32) & 0x0f) << 8usize);
        }
        #[doc = "USEMFTICK specifies whether the 4MHz constant-rate clock (MFCLK) to peripherals is enabled or disabled. When enabled, MDIV must be disabled (set to 0h=/1)."]
        #[inline(always)]
        pub const fn usemftick(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "USEMFTICK specifies whether the 4MHz constant-rate clock (MFCLK) to peripherals is enabled or disabled. When enabled, MDIV must be disabled (set to 0h=/1)."]
        #[inline(always)]
        pub fn set_usemftick(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "USELFCLK sets the MCLK source policy. Set USELFCLK to use LFCLK as the MCLK source. Note that setting USELFCLK does not disable SYSOSC, and SYSOSC remains available for direct use by analog modules."]
        #[inline(always)]
        pub const fn uselfclk(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "USELFCLK sets the MCLK source policy. Set USELFCLK to use LFCLK as the MCLK source. Note that setting USELFCLK does not disable SYSOSC, and SYSOSC remains available for direct use by analog modules."]
        #[inline(always)]
        pub fn set_uselfclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "STOPCLKSTBY sets the STANDBY mode policy (STANDBY0 or STANDBY1). When set, ULPCLK and LFCLK are disabled to all peripherals in STANDBY mode, with the exception of TIMG0 and TIMG1 which continue to run. Wake-up is only possible via an asynchronous fast clock request."]
        #[inline(always)]
        pub const fn stopclkstby(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "STOPCLKSTBY sets the STANDBY mode policy (STANDBY0 or STANDBY1). When set, ULPCLK and LFCLK are disabled to all peripherals in STANDBY mode, with the exception of TIMG0 and TIMG1 which continue to run. Wake-up is only possible via an asynchronous fast clock request."]
        #[inline(always)]
        pub fn set_stopclkstby(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "MCLKDEADCHK enables or disables the continuous MCLK dead check monitor. LFCLK must be running before MCLKDEADCHK is enabled."]
        #[inline(always)]
        pub const fn mclkdeadchk(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "MCLKDEADCHK enables or disables the continuous MCLK dead check monitor. LFCLK must be running before MCLKDEADCHK is enabled."]
        #[inline(always)]
        pub fn set_mclkdeadchk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Mclkcfg {
        #[inline(always)]
        fn default() -> Mclkcfg {
            Mclkcfg(0)
        }
    }
    #[doc = "NMI interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nmi(pub u32);
    impl Nmi {
        #[doc = "Clr the BORLVL NMI."]
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Clr the BORLVL NMI."]
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Watch Dog 0 Fault."]
        #[inline(always)]
        pub const fn wwdt0(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Watch Dog 0 Fault."]
        #[inline(always)]
        pub fn set_wwdt0(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Nmi {
        #[inline(always)]
        fn default() -> Nmi {
            Nmi(0)
        }
    }
    #[doc = "NMI interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nmiiidx(pub u32);
    impl Nmiiidx {
        #[doc = "The NMI interrupt index (NMIIIDX) register generates a value corresponding to the highest priority pending NMI source. This value may be used as an address offset for fast, deterministic handling in the NMI service routine. A read of the NMIIIDX register will clear the corresponding interrupt status in the NMIRIS register."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::NmiiidxStat {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::NmiiidxStat::from_bits(val as u8)
        }
        #[doc = "The NMI interrupt index (NMIIIDX) register generates a value corresponding to the highest priority pending NMI source. This value may be used as an address offset for fast, deterministic handling in the NMI service routine. A read of the NMIIIDX register will clear the corresponding interrupt status in the NMIRIS register."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::NmiiidxStat) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Nmiiidx {
        #[inline(always)]
        fn default() -> Nmiiidx {
            Nmiiidx(0)
        }
    }
    #[doc = "Power mode configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pmodecfg(pub u32);
    impl Pmodecfg {
        #[doc = "DSLEEP selects the operating mode to enter upon a DEEPSLEEP request from the CPU."]
        #[inline(always)]
        pub const fn dsleep(&self) -> super::vals::Dsleep {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Dsleep::from_bits(val as u8)
        }
        #[doc = "DSLEEP selects the operating mode to enter upon a DEEPSLEEP request from the CPU."]
        #[inline(always)]
        pub fn set_dsleep(&mut self, val: super::vals::Dsleep) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "SYSSRAMONSTOP selects whether the SRAM controller is enabled or disabled in STOP mode."]
        #[inline(always)]
        pub const fn syssramonstop(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "SYSSRAMONSTOP selects whether the SRAM controller is enabled or disabled in STOP mode."]
        #[inline(always)]
        pub fn set_syssramonstop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
    }
    impl Default for Pmodecfg {
        #[inline(always)]
        fn default() -> Pmodecfg {
            Pmodecfg(0)
        }
    }
    #[doc = "GPAMP control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pmuopamp(pub u32);
    impl Pmuopamp {
        #[doc = "Set ENABLE to turn on the GPAMP."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set ENABLE to turn on the GPAMP."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Set PCHENABLE to enable the positive channel input."]
        #[inline(always)]
        pub const fn pchenable(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Set PCHENABLE to enable the positive channel input."]
        #[inline(always)]
        pub fn set_pchenable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "NSEL selects the GPAMP negative channel input."]
        #[inline(always)]
        pub const fn nsel(&self) -> super::vals::Nsel {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::Nsel::from_bits(val as u8)
        }
        #[doc = "NSEL selects the GPAMP negative channel input."]
        #[inline(always)]
        pub fn set_nsel(&mut self, val: super::vals::Nsel) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "RRI selects the rail-to-rail input mode."]
        #[inline(always)]
        pub const fn rri(&self) -> super::vals::Rri {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::Rri::from_bits(val as u8)
        }
        #[doc = "RRI selects the rail-to-rail input mode."]
        #[inline(always)]
        pub fn set_rri(&mut self, val: super::vals::Rri) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
        #[doc = "Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin."]
        #[inline(always)]
        pub const fn outenable(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Set OUTENABLE to connect the GPAMP output signal to the GPAMP_OUT pin."]
        #[inline(always)]
        pub fn set_outenable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "CHOPCLKFREQ selects the GPAMP chopping clock frequency."]
        #[inline(always)]
        pub const fn chopclkfreq(&self) -> super::vals::Chopclkfreq {
            let val = (self.0 >> 8usize) & 0x03;
            super::vals::Chopclkfreq::from_bits(val as u8)
        }
        #[doc = "CHOPCLKFREQ selects the GPAMP chopping clock frequency."]
        #[inline(always)]
        pub fn set_chopclkfreq(&mut self, val: super::vals::Chopclkfreq) {
            self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
        }
        #[doc = "CHOPCLKMODE selects the GPAMP chopping mode."]
        #[inline(always)]
        pub const fn chopclkmode(&self) -> super::vals::Chopclkmode {
            let val = (self.0 >> 10usize) & 0x03;
            super::vals::Chopclkmode::from_bits(val as u8)
        }
        #[doc = "CHOPCLKMODE selects the GPAMP chopping mode."]
        #[inline(always)]
        pub fn set_chopclkmode(&mut self, val: super::vals::Chopclkmode) {
            self.0 = (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
        }
    }
    impl Default for Pmuopamp {
        #[inline(always)]
        fn default() -> Pmuopamp {
            Pmuopamp(0)
        }
    }
    #[doc = "Execute an application-triggered reset command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Resetcmd(pub u32);
    impl Resetcmd {
        #[doc = "Execute the reset specified in RESETLEVEL.LEVEL. Must be written together with the KEY."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Execute the reset specified in RESETLEVEL.LEVEL. Must be written together with the KEY."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetcmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetcmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetcmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Resetcmd {
        #[inline(always)]
        fn default() -> Resetcmd {
            Resetcmd(0)
        }
    }
    #[doc = "Reset level for application-triggered reset command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Resetlevel(pub u32);
    impl Resetlevel {
        #[doc = "LEVEL is used to specify the type of reset to be issued when RESETCMD is set to generate a software triggered reset."]
        #[inline(always)]
        pub const fn level(&self) -> super::vals::ResetlevelLevel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::ResetlevelLevel::from_bits(val as u8)
        }
        #[doc = "LEVEL is used to specify the type of reset to be issued when RESETCMD is set to generate a software triggered reset."]
        #[inline(always)]
        pub fn set_level(&mut self, val: super::vals::ResetlevelLevel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Resetlevel {
        #[inline(always)]
        fn default() -> Resetlevel {
            Resetlevel(0)
        }
    }
    #[doc = "Reset cause."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstcause(pub u32);
    impl Rstcause {
        #[doc = "ID is a read-to-clear field which indicates the lowest level reset cause since the last read."]
        #[inline(always)]
        pub const fn id(&self) -> super::vals::Id {
            let val = (self.0 >> 0usize) & 0x1f;
            super::vals::Id::from_bits(val as u8)
        }
        #[doc = "ID is a read-to-clear field which indicates the lowest level reset cause since the last read."]
        #[inline(always)]
        pub fn set_id(&mut self, val: super::vals::Id) {
            self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
        }
    }
    impl Default for Rstcause {
        #[inline(always)]
        fn default() -> Rstcause {
            Rstcause(0)
        }
    }
    #[doc = "SHUTDOWN IO release control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Shdniorel(pub u32);
    impl Shdniorel {
        #[doc = "Set RELEASE to release the IO after a SHUTDOWN mode exit."]
        #[inline(always)]
        pub const fn release(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set RELEASE to release the IO after a SHUTDOWN mode exit."]
        #[inline(always)]
        pub fn set_release(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ShdniorelKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ShdniorelKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ShdniorelKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Shdniorel {
        #[inline(always)]
        fn default() -> Shdniorel {
            Shdniorel(0)
        }
    }
    #[doc = "Shutdown storage memory (byte 0)."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Shutdnstore(pub u32);
    impl Shutdnstore {
        #[doc = "Shutdown storage byte 0."]
        #[inline(always)]
        pub const fn data(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Shutdown storage byte 0."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
        #[inline(always)]
        pub const fn parity(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_parity(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[inline(always)]
        pub const fn parityerr(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_parityerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
    }
    impl Default for Shutdnstore {
        #[inline(always)]
        fn default() -> Shutdnstore {
            Shutdnstore(0)
        }
    }
    #[doc = "SRAM Write Boundary."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sramboundary(pub u32);
    impl Sramboundary {
        #[doc = "SRAM boundary configuration. The value configured into this acts such that: SRAM accesses to addresses less than or equal value will be RW only. SRAM accesses to addresses greater than value will be RX only. Value of 0 is not valid (system will have no stack). If set to 0, the system acts as if the entire SRAM is RWX. Any non-zero value can be configured, including a value = SRAM size."]
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 5usize) & 0x7fff;
            val as u16
        }
        #[doc = "SRAM boundary configuration. The value configured into this acts such that: SRAM accesses to addresses less than or equal value will be RW only. SRAM accesses to addresses greater than value will be RX only. Value of 0 is not valid (system will have no stack). If set to 0, the system acts as if the entire SRAM is RWX. Any non-zero value can be configured, including a value = SRAM size."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0x7fff << 5usize)) | (((val as u32) & 0x7fff) << 5usize);
        }
    }
    impl Default for Sramboundary {
        #[inline(always)]
        fn default() -> Sramboundary {
            Sramboundary(0)
        }
    }
    #[doc = "Disable the SWD function on the SWD pins."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Swdcfg(pub u32);
    impl Swdcfg {
        #[doc = "Set DISABLE to disable the SWD function on SWD pins, allowing the SWD pins to be used as GPIO."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set DISABLE to disable the SWD function on SWD pins, allowing the SWD pins to be used as GPIO."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SwdcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SwdcfgKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SwdcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Swdcfg {
        #[inline(always)]
        fn default() -> Swdcfg {
            Swdcfg(0)
        }
    }
    #[doc = "SYSOSC configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysosccfg(pub u32);
    impl Sysosccfg {
        #[doc = "Target operating frequency for the system oscillator (SYSOSC)."]
        #[inline(always)]
        pub const fn freq(&self) -> super::vals::SysosccfgFreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::SysosccfgFreq::from_bits(val as u8)
        }
        #[doc = "Target operating frequency for the system oscillator (SYSOSC)."]
        #[inline(always)]
        pub fn set_freq(&mut self, val: super::vals::SysosccfgFreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "USE4MHZSTOP sets the SYSOSC stop mode frequency policy. When entering STOP mode, the SYSOSC frequency may be automatically switched to 4MHz to reduce SYSOSC power consumption."]
        #[inline(always)]
        pub const fn use4mhzstop(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "USE4MHZSTOP sets the SYSOSC stop mode frequency policy. When entering STOP mode, the SYSOSC frequency may be automatically switched to 4MHz to reduce SYSOSC power consumption."]
        #[inline(always)]
        pub fn set_use4mhzstop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "DISABLESTOP sets the SYSOSC stop mode enable/disable policy. When operating in STOP mode, the SYSOSC may be automatically disabled. When set, ULPCLK will run from LFCLK in STOP mode and SYSOSC will be disabled to reduce power consumption."]
        #[inline(always)]
        pub const fn disablestop(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "DISABLESTOP sets the SYSOSC stop mode enable/disable policy. When operating in STOP mode, the SYSOSC may be automatically disabled. When set, ULPCLK will run from LFCLK in STOP mode and SYSOSC will be disabled to reduce power consumption."]
        #[inline(always)]
        pub fn set_disablestop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "DISABLE sets the SYSOSC enable/disable policy. SYSOSC may be powered off in RUN, SLEEP, and STOP modes to reduce power consumption. When SYSOSC is disabled, MCLK and ULPCLK are sourced from LFCLK."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "DISABLE sets the SYSOSC enable/disable policy. SYSOSC may be powered off in RUN, SLEEP, and STOP modes to reduce power consumption. When SYSOSC is disabled, MCLK and ULPCLK are sourced from LFCLK."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "BLOCKASYNCALL may be used to mask block all asynchronous fast clock requests, preventing hardware from dynamically changing the active clock configuration when operating in a given mode."]
        #[inline(always)]
        pub const fn blockasyncall(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "BLOCKASYNCALL may be used to mask block all asynchronous fast clock requests, preventing hardware from dynamically changing the active clock configuration when operating in a given mode."]
        #[inline(always)]
        pub fn set_blockasyncall(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "FASTCPUEVENT may be used to assert a fast clock request when an interrupt is asserted to the CPU, reducing interrupt latency."]
        #[inline(always)]
        pub const fn fastcpuevent(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "FASTCPUEVENT may be used to assert a fast clock request when an interrupt is asserted to the CPU, reducing interrupt latency."]
        #[inline(always)]
        pub fn set_fastcpuevent(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Sysosccfg {
        #[inline(always)]
        fn default() -> Sysosccfg {
            Sysosccfg(0)
        }
    }
    #[doc = "SYSOSC frequency correction loop (FCL) ROSC enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysoscfclctl(pub u32);
    impl Sysoscfclctl {
        #[doc = "Set SETUSEFCL to enable the frequency correction loop in SYSOSC. An appropriate resistor must be populated on the ROSC pin. Once enabled, this state is locked until the next BOOTRST."]
        #[inline(always)]
        pub const fn setusefcl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set SETUSEFCL to enable the frequency correction loop in SYSOSC. An appropriate resistor must be populated on the ROSC pin. Once enabled, this state is locked until the next BOOTRST."]
        #[inline(always)]
        pub fn set_setusefcl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SysoscfclctlKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SysoscfclctlKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SysoscfclctlKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Sysoscfclctl {
        #[inline(always)]
        fn default() -> Sysoscfclctl {
            Sysoscfclctl(0)
        }
    }
    #[doc = "SYSOSC user-specified trim."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysosctrimuser(pub u32);
    impl Sysosctrimuser {
        #[doc = "FREQ specifies the target user-trimmed frequency for SYSOSC."]
        #[inline(always)]
        pub const fn freq(&self) -> super::vals::SysosctrimuserFreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::SysosctrimuserFreq::from_bits(val as u8)
        }
        #[doc = "FREQ specifies the target user-trimmed frequency for SYSOSC."]
        #[inline(always)]
        pub fn set_freq(&mut self, val: super::vals::SysosctrimuserFreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "CAP specifies the SYSOSC capacitor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn cap(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x07;
            val as u8
        }
        #[doc = "CAP specifies the SYSOSC capacitor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_cap(&mut self, val: u8) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
        }
        #[doc = "RESCOARSE specifies the resister coarse trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn rescoarse(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x3f;
            val as u8
        }
        #[doc = "RESCOARSE specifies the resister coarse trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_rescoarse(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
        }
        #[doc = "RESFINE specifies the resister fine trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn resfine(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x0f;
            val as u8
        }
        #[doc = "RESFINE specifies the resister fine trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_resfine(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
        }
        #[doc = "RDIV specifies the frequency correction loop (FCL) resistor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn rdiv(&self) -> u16 {
            let val = (self.0 >> 20usize) & 0x01ff;
            val as u16
        }
        #[doc = "RDIV specifies the frequency correction loop (FCL) resistor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_rdiv(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 20usize)) | (((val as u32) & 0x01ff) << 20usize);
        }
    }
    impl Default for Sysosctrimuser {
        #[inline(always)]
        fn default() -> Sysosctrimuser {
            Sysosctrimuser(0)
        }
    }
    #[doc = "System status information."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysstatus(pub u32);
    impl Sysstatus {
        #[doc = "BORCURTHRESHOLD indicates the active brown-out reset supply monitor configuration."]
        #[inline(always)]
        pub const fn borcurthreshold(&self) -> super::vals::Borcurthreshold {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::Borcurthreshold::from_bits(val as u8)
        }
        #[doc = "BORCURTHRESHOLD indicates the active brown-out reset supply monitor configuration."]
        #[inline(always)]
        pub fn set_borcurthreshold(&mut self, val: super::vals::Borcurthreshold) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "BORLVL indicates if a BOR event occured and the BOR threshold was switched to BOR0 by hardware."]
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BORLVL indicates if a BOR event occured and the BOR threshold was switched to BOR0 by hardware."]
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ANACPUMPGOOD is set by hardware when the VBOOST analog mux charge pump is ready."]
        #[inline(always)]
        pub const fn anacpumpgood(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ANACPUMPGOOD is set by hardware when the VBOOST analog mux charge pump is ready."]
        #[inline(always)]
        pub fn set_anacpumpgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PMUIREFGOOD is set by hardware when the PMU current reference is ready."]
        #[inline(always)]
        pub const fn pmuirefgood(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PMUIREFGOOD is set by hardware when the PMU current reference is ready."]
        #[inline(always)]
        pub fn set_pmuirefgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "EXTRSTPINDIS indicates when user has disabled the use of external reset pin."]
        #[inline(always)]
        pub const fn extrstpindis(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "EXTRSTPINDIS indicates when user has disabled the use of external reset pin."]
        #[inline(always)]
        pub fn set_extrstpindis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SWDCFGDIS indicates when user has disabled the use of SWD Port."]
        #[inline(always)]
        pub const fn swdcfgdis(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SWDCFGDIS indicates when user has disabled the use of SWD Port."]
        #[inline(always)]
        pub fn set_swdcfgdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SHDNIOLOCK indicates when IO is locked due to SHUTDOWN."]
        #[inline(always)]
        pub const fn shdniolock(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SHDNIOLOCK indicates when IO is locked due to SHUTDOWN."]
        #[inline(always)]
        pub fn set_shdniolock(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "REBOOTATTEMPTS indicates the number of boot attempts taken before the user application starts."]
        #[inline(always)]
        pub const fn rebootattempts(&self) -> u8 {
            let val = (self.0 >> 30usize) & 0x03;
            val as u8
        }
        #[doc = "REBOOTATTEMPTS indicates the number of boot attempts taken before the user application starts."]
        #[inline(always)]
        pub fn set_rebootattempts(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize);
        }
    }
    impl Default for Sysstatus {
        #[inline(always)]
        fn default() -> Sysstatus {
            Sysstatus(0)
        }
    }
    #[doc = "Clear sticky bits of SYSSTATUS."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysstatusclr(pub u32);
    impl Sysstatusclr {
        #[doc = "Set ALLECC to clear all ECC related SYSSTATUS indicators."]
        #[inline(always)]
        pub const fn allecc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set ALLECC to clear all ECC related SYSSTATUS indicators."]
        #[inline(always)]
        pub fn set_allecc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SysstatusclrKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SysstatusclrKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SysstatusclrKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Sysstatusclr {
        #[inline(always)]
        fn default() -> Sysstatusclr {
            Sysstatusclr(0)
        }
    }
    #[doc = "System configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Systemcfg(pub u32);
    impl Systemcfg {
        #[doc = "WWDTLP0RSTDIS specifies whether a WWDT Error Event will trigger a BOOTRST or an NMI."]
        #[inline(always)]
        pub const fn wwdtlp0rstdis(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "WWDTLP0RSTDIS specifies whether a WWDT Error Event will trigger a BOOTRST or an NMI."]
        #[inline(always)]
        pub fn set_wwdtlp0rstdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Systemcfg {
        #[inline(always)]
        fn default() -> Systemcfg {
            Systemcfg(0)
        }
    }
    #[doc = "SYSCTL register write lockout."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Writelock(pub u32);
    impl Writelock {
        #[doc = "ACTIVE controls whether critical SYSCTL registers are write protected or not."]
        #[inline(always)]
        pub const fn active(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACTIVE controls whether critical SYSCTL registers are write protected or not."]
        #[inline(always)]
        pub fn set_active(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Writelock {
        #[inline(always)]
        fn default() -> Writelock {
            Writelock(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Anacpumpcfg {
        #[doc = "VBOOST is enabled on request from a COMP, GPAMP, or OPA."]
        ONDEMAND = 0x0,
        #[doc = "VBOOST is enabled when the device is in RUN or SLEEP mode, or when a COMP/GPAMP/OPA is enabled."]
        ONACTIVE = 0x01,
        #[doc = "VBOOST is always enabled."]
        ONALWAYS = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Anacpumpcfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Anacpumpcfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Anacpumpcfg {
        #[inline(always)]
        fn from(val: u8) -> Anacpumpcfg {
            Anacpumpcfg::from_bits(val)
        }
    }
    impl From<Anacpumpcfg> for u8 {
        #[inline(always)]
        fn from(val: Anacpumpcfg) -> u8 {
            Anacpumpcfg::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct BorclrcmdKey(pub u8);
    impl BorclrcmdKey {
        pub const KEY: Self = Self(0xc7);
    }
    impl BorclrcmdKey {
        pub const fn from_bits(val: u8) -> BorclrcmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for BorclrcmdKey {
        #[inline(always)]
        fn from(val: u8) -> BorclrcmdKey {
            BorclrcmdKey::from_bits(val)
        }
    }
    impl From<BorclrcmdKey> for u8 {
        #[inline(always)]
        fn from(val: BorclrcmdKey) -> u8 {
            BorclrcmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Borcurthreshold {
        #[doc = "Default minimum threshold; a BOR0- violation triggers a BOR."]
        BORMIN = 0x0,
        #[doc = "A BOR1- violation generates a BORLVL interrupt."]
        BORLEVEL1 = 0x01,
        #[doc = "A BOR2- violation generates a BORLVL interrupt."]
        BORLEVEL2 = 0x02,
        #[doc = "A BOR3- violation generates a BORLVL interrupt."]
        BORLEVEL3 = 0x03,
    }
    impl Borcurthreshold {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Borcurthreshold {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Borcurthreshold {
        #[inline(always)]
        fn from(val: u8) -> Borcurthreshold {
            Borcurthreshold::from_bits(val)
        }
    }
    impl From<Borcurthreshold> for u8 {
        #[inline(always)]
        fn from(val: Borcurthreshold) -> u8 {
            Borcurthreshold::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Chopclkfreq {
        #[doc = "16kHz."]
        CLK16KHZ = 0x0,
        #[doc = "8kHz."]
        CLK8KHZ = 0x01,
        #[doc = "4kHz."]
        CLK4KHZ = 0x02,
        #[doc = "2kHz."]
        CLK2KHZ = 0x03,
    }
    impl Chopclkfreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Chopclkfreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Chopclkfreq {
        #[inline(always)]
        fn from(val: u8) -> Chopclkfreq {
            Chopclkfreq::from_bits(val)
        }
    }
    impl From<Chopclkfreq> for u8 {
        #[inline(always)]
        fn from(val: Chopclkfreq) -> u8 {
            Chopclkfreq::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Chopclkmode {
        #[doc = "Chopping disabled."]
        CHOPDISABLED = 0x0,
        #[doc = "Normal chopping."]
        REGCHOP = 0x01,
        #[doc = "ADC Assisted chopping."]
        ADCASSIST = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Chopclkmode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Chopclkmode {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Chopclkmode {
        #[inline(always)]
        fn from(val: u8) -> Chopclkmode {
            Chopclkmode::from_bits(val)
        }
    }
    impl From<Chopclkmode> for u8 {
        #[inline(always)]
        fn from(val: Chopclkmode) -> u8 {
            Chopclkmode::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Dsleep {
        #[doc = "STOP mode is entered."]
        STOP = 0x0,
        #[doc = "STANDBY mode is entered."]
        STANDBY = 0x01,
        #[doc = "SHUTDOWN mode is entered."]
        SHUTDOWN = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Dsleep {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dsleep {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dsleep {
        #[inline(always)]
        fn from(val: u8) -> Dsleep {
            Dsleep::from_bits(val)
        }
    }
    impl From<Dsleep> for u8 {
        #[inline(always)]
        fn from(val: Dsleep) -> u8 {
            Dsleep::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Exclkdivval {
        #[doc = "CLK_OUT source is divided by 2."]
        DIV2 = 0x0,
        #[doc = "CLK_OUT source is divided by 4."]
        DIV4 = 0x01,
        #[doc = "CLK_OUT source is divided by 6."]
        DIV6 = 0x02,
        #[doc = "CLK_OUT source is divided by 8."]
        DIV8 = 0x03,
        #[doc = "CLK_OUT source is divided by 10."]
        DIV10 = 0x04,
        #[doc = "CLK_OUT source is divided by 12."]
        DIV12 = 0x05,
        #[doc = "CLK_OUT source is divided by 14."]
        DIV14 = 0x06,
        #[doc = "CLK_OUT source is divided by 16."]
        DIV16 = 0x07,
    }
    impl Exclkdivval {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Exclkdivval {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Exclkdivval {
        #[inline(always)]
        fn from(val: u8) -> Exclkdivval {
            Exclkdivval::from_bits(val)
        }
    }
    impl From<Exclkdivval> for u8 {
        #[inline(always)]
        fn from(val: Exclkdivval) -> u8 {
            Exclkdivval::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Exclksrc {
        #[doc = "CLK_OUT is SYSOSC."]
        SYSOSC = 0x0,
        #[doc = "CLK_OUT is ULPCLK (EXCLKDIVEN must be enabled)."]
        ULPCLK = 0x01,
        #[doc = "CLK_OUT is LFCLK."]
        LFCLK = 0x02,
        #[doc = "CLK_OUT is MFPCLK (EXCLKDIVEN must be enabled)."]
        MFPCLK = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Exclksrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Exclksrc {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Exclksrc {
        #[inline(always)]
        fn from(val: u8) -> Exclksrc {
            Exclksrc::from_bits(val)
        }
    }
    impl From<Exclksrc> for u8 {
        #[inline(always)]
        fn from(val: Exclksrc) -> u8 {
            Exclksrc::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ExrstpinKey(pub u8);
    impl ExrstpinKey {
        pub const KEY: Self = Self(0x1e);
    }
    impl ExrstpinKey {
        pub const fn from_bits(val: u8) -> ExrstpinKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ExrstpinKey {
        #[inline(always)]
        fn from(val: u8) -> ExrstpinKey {
            ExrstpinKey::from_bits(val)
        }
    }
    impl From<ExrstpinKey> for u8 {
        #[inline(always)]
        fn from(val: ExrstpinKey) -> u8 {
            ExrstpinKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct FcccmdKey(pub u8);
    impl FcccmdKey {
        pub const KEY: Self = Self(0x0e);
    }
    impl FcccmdKey {
        pub const fn from_bits(val: u8) -> FcccmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for FcccmdKey {
        #[inline(always)]
        fn from(val: u8) -> FcccmdKey {
            FcccmdKey::from_bits(val)
        }
    }
    impl From<FcccmdKey> for u8 {
        #[inline(always)]
        fn from(val: FcccmdKey) -> u8 {
            FcccmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fcclvltrig {
        #[doc = "Rising edge to rising edge triggered."]
        RISE2RISE = 0x0,
        #[doc = "Level triggered."]
        LEVEL = 0x01,
    }
    impl Fcclvltrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fcclvltrig {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fcclvltrig {
        #[inline(always)]
        fn from(val: u8) -> Fcclvltrig {
            Fcclvltrig::from_bits(val)
        }
    }
    impl From<Fcclvltrig> for u8 {
        #[inline(always)]
        fn from(val: Fcclvltrig) -> u8 {
            Fcclvltrig::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fccselclk {
        #[doc = "FCC clock is MCLK."]
        MCLK = 0x0,
        #[doc = "FCC clock is SYSOSC."]
        SYSOSC = 0x01,
        _RESERVED_2 = 0x02,
        #[doc = "FCC clock is the CLK_OUT selection."]
        EXTCLK = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        #[doc = "FCC clock is the FCCIN external input."]
        FCCIN = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Fccselclk {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fccselclk {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fccselclk {
        #[inline(always)]
        fn from(val: u8) -> Fccselclk {
            Fccselclk::from_bits(val)
        }
    }
    impl From<Fccselclk> for u8 {
        #[inline(always)]
        fn from(val: Fccselclk) -> u8 {
            Fccselclk::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fcctrigsrc {
        #[doc = "FCC trigger is the external pin."]
        EXTPIN = 0x0,
        #[doc = "FCC trigger is the LFCLK."]
        LFCLK = 0x01,
    }
    impl Fcctrigsrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fcctrigsrc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fcctrigsrc {
        #[inline(always)]
        fn from(val: u8) -> Fcctrigsrc {
            Fcctrigsrc::from_bits(val)
        }
    }
    impl From<Fcctrigsrc> for u8 {
        #[inline(always)]
        fn from(val: Fcctrigsrc) -> u8 {
            Fcctrigsrc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Flashwait {
        #[doc = "No flash wait states are applied."]
        WAIT0 = 0x0,
        #[doc = "One flash wait state is applied."]
        WAIT1 = 0x01,
        #[doc = "2 flash wait states are applied."]
        WAIT2 = 0x02,
        _RESERVED_3 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Flashwait {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Flashwait {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Flashwait {
        #[inline(always)]
        fn from(val: u8) -> Flashwait {
            Flashwait::from_bits(val)
        }
    }
    impl From<Flashwait> for u8 {
        #[inline(always)]
        fn from(val: Flashwait) -> u8 {
            Flashwait::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Id {
        #[doc = "No reset since last read."]
        NORST = 0x0,
        #[doc = "POR- violation, SHUTDNSTOREx or PMU trim parity fault."]
        PORHWFAIL = 0x01,
        #[doc = "NRST triggered POR (&gt;1s hold)."]
        POREXNRST = 0x02,
        #[doc = "Software triggered POR."]
        PORSW = 0x03,
        #[doc = "BOR0- violation."]
        BORSUPPLY = 0x04,
        #[doc = "SHUTDOWN mode exit."]
        BORWAKESHUTDN = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        #[doc = "Non-PMU trim parity fault."]
        BOOTNONPMUPARITY = 0x08,
        #[doc = "Fatal clock failure."]
        BOOTCLKFAIL = 0x09,
        #[doc = "Software triggered BOOTRST."]
        BOOTSW = 0x0a,
        _RESERVED_b = 0x0b,
        #[doc = "NRST triggered BOOTRST (&lt;1s hold)."]
        BOOTEXNRST = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
        #[doc = "BSL exit."]
        SYSBSLEXIT = 0x10,
        #[doc = "BSL entry."]
        SYSBSLENTRY = 0x11,
        #[doc = "WWDT0 violation."]
        SYSWWDT0 = 0x12,
        #[doc = "WWDT1 violation."]
        SYSWWDT1 = 0x13,
        #[doc = "Flash uncorrectable ECC error."]
        SYSFLASHECC = 0x14,
        #[doc = "CPULOCK violation."]
        SYSCPULOCK = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        #[doc = "Debug triggered SYSRST."]
        SYSDBG = 0x1a,
        #[doc = "Software triggered SYSRST."]
        SYSSW = 0x1b,
        #[doc = "Debug triggered CPURST."]
        CPUDBG = 0x1c,
        #[doc = "Software triggered CPURST."]
        CPUSW = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
    }
    impl Id {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Id {
            unsafe { core::mem::transmute(val & 0x1f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Id {
        #[inline(always)]
        fn from(val: u8) -> Id {
            Id::from_bits(val)
        }
    }
    impl From<Id> for u8 {
        #[inline(always)]
        fn from(val: Id) -> u8 {
            Id::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum IidxStat {
        #[doc = "No interrupt pending."]
        NO_INTR = 0x0,
        #[doc = "LFOSCGOOD interrupt pending."]
        LFOSCGOOD = 0x01,
        BORLVL = 0x02,
        ANACLKERR = 0x03,
    }
    impl IidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> IidxStat {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for IidxStat {
        #[inline(always)]
        fn from(val: u8) -> IidxStat {
            IidxStat::from_bits(val)
        }
    }
    impl From<IidxStat> for u8 {
        #[inline(always)]
        fn from(val: IidxStat) -> u8 {
            IidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Lfclkmux {
        #[doc = "LFCLK is sourced from the internal LFOSC."]
        LFOSC = 0x0,
        #[doc = "LFCLK is sourced from the LFXT (crystal)."]
        LFXT = 0x01,
        #[doc = "LFCLK is sourced from LFCLK_IN (external digital clock input)."]
        EXLF = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Lfclkmux {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lfclkmux {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lfclkmux {
        #[inline(always)]
        fn from(val: u8) -> Lfclkmux {
            Lfclkmux::from_bits(val)
        }
    }
    impl From<Lfclkmux> for u8 {
        #[inline(always)]
        fn from(val: Lfclkmux) -> u8 {
            Lfclkmux::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum NmiiidxStat {
        #[doc = "No NMI pending."]
        NO_INTR = 0x0,
        #[doc = "BOR Threshold NMI pending."]
        BORLVL = 0x01,
        WWDT0 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl NmiiidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> NmiiidxStat {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for NmiiidxStat {
        #[inline(always)]
        fn from(val: u8) -> NmiiidxStat {
            NmiiidxStat::from_bits(val)
        }
    }
    impl From<NmiiidxStat> for u8 {
        #[inline(always)]
        fn from(val: NmiiidxStat) -> u8 {
            NmiiidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Nsel {
        #[doc = "GPAMP_OUT pin connected to negative channel."]
        SEL0 = 0x0,
        #[doc = "GPAMP_IN- pin connected to negative channel."]
        SEL1 = 0x01,
        #[doc = "GPAMP_OUT signal connected to negative channel."]
        SEL2 = 0x02,
        #[doc = "No channel selected."]
        SEL3 = 0x03,
    }
    impl Nsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Nsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Nsel {
        #[inline(always)]
        fn from(val: u8) -> Nsel {
            Nsel::from_bits(val)
        }
    }
    impl From<Nsel> for u8 {
        #[inline(always)]
        fn from(val: Nsel) -> u8 {
            Nsel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetcmdKey(pub u8);
    impl ResetcmdKey {
        pub const KEY: Self = Self(0xe4);
    }
    impl ResetcmdKey {
        pub const fn from_bits(val: u8) -> ResetcmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetcmdKey {
        #[inline(always)]
        fn from(val: u8) -> ResetcmdKey {
            ResetcmdKey::from_bits(val)
        }
    }
    impl From<ResetcmdKey> for u8 {
        #[inline(always)]
        fn from(val: ResetcmdKey) -> u8 {
            ResetcmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum ResetlevelLevel {
        #[doc = "Issue a SYSRST (CPU plus peripherals only)."]
        CPU = 0x0,
        #[doc = "Issue a BOOTRST (CPU, peripherals, and boot configuration routine)."]
        BOOT = 0x01,
        #[doc = "Issue a SYSRST and enter the boot strap loader (BSL)."]
        BOOTLOADERENTRY = 0x02,
        #[doc = "Issue a power-on reset (POR)."]
        POR = 0x03,
        #[doc = "Issue a SYSRST and exit the boot strap loader (BSL)."]
        BOOTLOADEREXIT = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl ResetlevelLevel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> ResetlevelLevel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for ResetlevelLevel {
        #[inline(always)]
        fn from(val: u8) -> ResetlevelLevel {
            ResetlevelLevel::from_bits(val)
        }
    }
    impl From<ResetlevelLevel> for u8 {
        #[inline(always)]
        fn from(val: ResetlevelLevel) -> u8 {
            ResetlevelLevel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Rri {
        #[doc = "PMOS input pairs."]
        MODE0 = 0x0,
        #[doc = "NMOS input pairs."]
        MODE1 = 0x01,
        #[doc = "Rail-to-rail mode."]
        MODE2 = 0x02,
        #[doc = "Sample channel 0."]
        MODE3 = 0x03,
    }
    impl Rri {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Rri {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Rri {
        #[inline(always)]
        fn from(val: u8) -> Rri {
            Rri::from_bits(val)
        }
    }
    impl From<Rri> for u8 {
        #[inline(always)]
        fn from(val: Rri) -> u8 {
            Rri::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ShdniorelKey(pub u8);
    impl ShdniorelKey {
        pub const KEY: Self = Self(0x91);
    }
    impl ShdniorelKey {
        pub const fn from_bits(val: u8) -> ShdniorelKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ShdniorelKey {
        #[inline(always)]
        fn from(val: u8) -> ShdniorelKey {
            ShdniorelKey::from_bits(val)
        }
    }
    impl From<ShdniorelKey> for u8 {
        #[inline(always)]
        fn from(val: ShdniorelKey) -> u8 {
            ShdniorelKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SwdcfgKey(pub u8);
    impl SwdcfgKey {
        pub const KEY: Self = Self(0x62);
    }
    impl SwdcfgKey {
        pub const fn from_bits(val: u8) -> SwdcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SwdcfgKey {
        #[inline(always)]
        fn from(val: u8) -> SwdcfgKey {
            SwdcfgKey::from_bits(val)
        }
    }
    impl From<SwdcfgKey> for u8 {
        #[inline(always)]
        fn from(val: SwdcfgKey) -> u8 {
            SwdcfgKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum SysosccfgFreq {
        #[doc = "Base frequency (32MHz)."]
        SYSOSCBASE = 0x0,
        #[doc = "Low frequency (4MHz)."]
        SYSOSC4M = 0x01,
        #[doc = "User-trimmed frequency (16 or 24 MHz)."]
        SYSOSCUSER = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl SysosccfgFreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> SysosccfgFreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for SysosccfgFreq {
        #[inline(always)]
        fn from(val: u8) -> SysosccfgFreq {
            SysosccfgFreq::from_bits(val)
        }
    }
    impl From<SysosccfgFreq> for u8 {
        #[inline(always)]
        fn from(val: SysosccfgFreq) -> u8 {
            SysosccfgFreq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SysoscfclctlKey(pub u8);
    impl SysoscfclctlKey {
        pub const KEY: Self = Self(0x2a);
    }
    impl SysoscfclctlKey {
        pub const fn from_bits(val: u8) -> SysoscfclctlKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SysoscfclctlKey {
        #[inline(always)]
        fn from(val: u8) -> SysoscfclctlKey {
            SysoscfclctlKey::from_bits(val)
        }
    }
    impl From<SysoscfclctlKey> for u8 {
        #[inline(always)]
        fn from(val: SysoscfclctlKey) -> u8 {
            SysoscfclctlKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sysoscfreq {
        #[doc = "SYSOSC is at base frequency (32MHz)."]
        SYSOSC32M = 0x0,
        #[doc = "SYSOSC is at low frequency (4MHz)."]
        SYSOSC4M = 0x01,
        #[doc = "SYSOSC is at the user-trimmed frequency (16 or 24MHz)."]
        SYSOSCUSER = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Sysoscfreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sysoscfreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sysoscfreq {
        #[inline(always)]
        fn from(val: u8) -> Sysoscfreq {
            Sysoscfreq::from_bits(val)
        }
    }
    impl From<Sysoscfreq> for u8 {
        #[inline(always)]
        fn from(val: Sysoscfreq) -> u8 {
            Sysoscfreq::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum SysosctrimuserFreq {
        _RESERVED_0 = 0x0,
        #[doc = "16MHz user frequency."]
        SYSOSC16M = 0x01,
        #[doc = "24MHz user frequency."]
        SYSOSC24M = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl SysosctrimuserFreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> SysosctrimuserFreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for SysosctrimuserFreq {
        #[inline(always)]
        fn from(val: u8) -> SysosctrimuserFreq {
            SysosctrimuserFreq::from_bits(val)
        }
    }
    impl From<SysosctrimuserFreq> for u8 {
        #[inline(always)]
        fn from(val: SysosctrimuserFreq) -> u8 {
            SysosctrimuserFreq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SysstatusclrKey(pub u8);
    impl SysstatusclrKey {
        pub const KEY: Self = Self(0xce);
    }
    impl SysstatusclrKey {
        pub const fn from_bits(val: u8) -> SysstatusclrKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SysstatusclrKey {
        #[inline(always)]
        fn from(val: u8) -> SysstatusclrKey {
            SysstatusclrKey::from_bits(val)
        }
    }
    impl From<SysstatusclrKey> for u8 {
        #[inline(always)]
        fn from(val: SysstatusclrKey) -> u8 {
            SysstatusclrKey::to_bits(val)
        }
    }
}
